<!DOCTYPE html>
<meta charset="utf-8">
<link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
<style>
  body {
    font-family: 'Lato', sans-serif;
    margin: 0;
    padding: 0;
  }
  svg {
    width: 100%;
    height: 800px;
  }
</style>
<body>
<svg></svg>
<button id="exportBtn" style="margin: 1rem;">Esporta PNG (300 DPI)</button>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const margin = {top: 20, right: 180, bottom: 30, left: 60},
      width = 1500 - margin.left - margin.right,
      height = 800 - margin.top - margin.bottom,
      fontSize = Math.max(10, width / 60);

const svg = d3.select("svg")
  .attr("width", width + margin.left + margin.right)
  .attr("height", height + margin.top + margin.bottom)
  .append("g")
  .attr("transform", `translate(${margin.left},${margin.top})`)
  .style("font-family", "'Lato', sans-serif");

d3.csv("streamgraph_data.csv", d3.autoType).then(data => {
  const intervals = Array.from(new Set(data.map(d => d.Interval))).sort((a,b) => a - b);
  const categories = Array.from(new Set(data.map(d => d.Category)));

  // Somma totale delle pagine per categoria
const categoryTotals = d3.rollup(
  data,
  v => d3.sum(v, d => d.Pages),
  d => d.Category
);

// Ordina le chiavi in base al totale decrescente
const keys = Array.from(categoryTotals.entries())
  .sort((a, b) => d3.descending(a[1], b[1]))
  .map(d => d[0]);

  // Aggrega i dati in forma: {Interval, Cat1, Cat2, ...}
  const nested = d3.rollup(
    data,
    v => Object.fromEntries(v.map(d => [d.Category, d.Pages])),
    d => d.Interval
  );

  const flat = intervals.map(interval => {
    const row = {Interval: interval};
    const values = nested.get(interval) || {};
    categories.forEach(cat => {
      row[cat] = values[cat] || 0;
    });
    return row;
  });

  // Stack generator
  const stack = d3.stack()
    .keys(categories)
    .order(d3.stackOrderNone)
    .offset(d3.stackOffsetNone);  // â† NESSUN centramento verticale

  const series = stack(flat);

  const x = d3.scaleLinear()
    .domain(d3.extent(intervals))
    .range([0, width]);

  const y = d3.scaleLinear()
    .domain([0, d3.max(series, s => d3.max(s, d => d[1]))])
    .range([height, 0]);

  const color = d3.scaleOrdinal()
    .domain(categories)
    .range(d3.schemeTableau10);

  svg.selectAll("path")
    .data(series)
    .join("path")
    .attr("fill", d => color(d.key))
    .attr("d", d3.area()
      .x(d => x(d.data.Interval))
      .y0(d => y(d[0]))
      .y1(d => y(d[1]))
      .curve(d3.curveBasis)
    );

  // Asse X: visibile
  svg.append("g")
    .attr("transform", `translate(0,${height})`)
    .call(d3.axisBottom(x).tickFormat(d3.format("d")))
    .selectAll("text")
    .style("font-size", fontSize + "px");

  // Asse Y: nascosto
  svg.append("g")
    .call(d3.axisLeft(y))
    .attr("display", "none");

 // Legenda in alto a sinistra "dentro" il grafico
const legend = svg.append("g")
  .attr("transform", `translate(10, 200)`); // margine interno

  const orderedCategories = [
  "D. Logic",
  "B. Pragmatism",
  "A. Mathematics",
  "E. Metaphysics",
];

const legendSpacing = fontSize * 1.4;

  orderedCategories.forEach((cat, i) => {
  const yPos = i * legendSpacing;
  legend.append("rect")
    .attr("x", 0)
    .attr("y", yPos)
    .attr("width", 12)
    .attr("height", 12)
    .attr("fill", color(cat));
  legend.append("text")
    .attr("x", 18)
    .attr("y", yPos + fontSize * 0.8)  // centrato verticalmente
    .attr("font-size", fontSize + "px")
    .text(cat);
});
});
</script>
<script>
document.getElementById("exportBtn").addEventListener("click", function() {
  const svgElement = document.querySelector("svg");

  const svgData = new XMLSerializer().serializeToString(svgElement);
  const svgBlob = new Blob([svgData], {type: "image/svg+xml;charset=utf-8"});
  const url = URL.createObjectURL(svgBlob);

  const image = new Image();
  image.onload = function() {
    const dpi = 300;
    const scaleFactor = dpi / 96; // 96 DPI is default browser resolution

    const canvas = document.createElement("canvas");
    canvas.width = svgElement.clientWidth * scaleFactor;
    canvas.height = svgElement.clientHeight * scaleFactor;

    const context = canvas.getContext("2d");
    context.scale(scaleFactor, scaleFactor);
    context.fillStyle = "#ffffff";
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.drawImage(image, 0, 0);

    const png = canvas.toDataURL("image/png");

    const a = document.createElement("a");
    a.download = "streamgraph_300dpi.png";
    a.href = png;
    a.click();

    URL.revokeObjectURL(url);
  };
  image.src = url;
});
</script>
</body>